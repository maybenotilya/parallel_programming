# Задача 1. Стек Трайбера

На лекциях в осеннем семестре обсуждалось, как сделать работу со стеком
потокобезопасной. Первым делом вам следует просто реализовать те алгоритмы для
трёх основных операций (вставка, удаление, просмотр верхнего элемента), которые
мы разбирали вместе на занятии.

Далее следует изучить принцип работы оптимизации с элиминацией и дополнить ей
вашу реализацию стека.
Ожидается некоторое покрытие кода тестами, которые могли бы в той или иной
степени убедить проверяющего в корректности решения.

Наконец, необходимо провести численный эксперимент

- на случайных данных
- на специально подобранных данных,

призванный оценить эффективность оптимизации с элиминацией. Кстати говоря, что
по этому поводу говорят сами авторы оптимизации?

Комментарий. Язык программирования — любой со сборщиком мусора, где вы
сможете продуцировать ООП-код с продуманными и осмысленными
дизайн-решениями, а также где в стандартной библиотеке есть всякие вещи вроде
atomic или CAS. Обратите внимание, что для Kotlin существует специальный
фреймворк Lincheck, который позволяет делать более качественные тесты. Если вы
выбираете другой язык, задумайтесь о том, чем компенсировать отсутствие Lincheck’a.

# Тесты

Код покрыт стресс-тестами и модельными тестами фреймворка Lincheck. Однако у него есть недостаток: при достаточно
больших порогах ожидания ещё одной операции при работе стека с элиминацией он сообщает о deadlock'е, которого там нет.
Это не критично, так как использовать большое время ожидания нецелесообразно.

# Численный эксперимент

Эксперимент проводился на следующем тестовом стенде

- 12th Gen Intel i5-12500H (16) @ 4.500GHz
- 16 Gb RAM
- OpenJDK 22 2024-03-19

Замеры производились на следующих данных:

1. 5_000_000 операций на один поток
2. 2 потока (корутины)
3. 100 итераций ожидания дополнительной операции push/pop

В качестве результата бралось среднее по 5 запускам.

Тестировались 3 сценария:

1. Только операции `push`
2. Сначала 5_000_00 операций `push`, потом вдвое больше операций `pop`
3. Два потока, один из который делает только операции `push`, другой -- `pop`

Результаты получились следующие:

```
Running push only case:
 - Concurrent stack:  902 ms.
 - Elimination stack: 1584 ms.

Running pop only case:
 - Concurrent stack:  3536 ms.
 - Elimination stack: 3991 ms.

Running alternate case:
 - Concurrent stack:  400 ms.
 - Elimination stack: 230 ms.
```

# Вывод

Стек с элиминацией действительно показывает лучшие результаты, когда операций `push` примерно столько же, сколько
операций `pop`, и они равномерно распределены. В остальных синтетических случаях (только `push` и только `pop`) стек с
элиминацией проигрывает из-за дополнительных расходов на ожидание и проверку, хотя и не так сильно, чтобы это стало
критично.